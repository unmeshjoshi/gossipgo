// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: data.proto

package proto

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// IsolationType TODO(jiajia) Needs documentation.
type IsolationType int32

const (
	// SERIALIZABLE TODO(jiajia) Needs documentation.
	SERIALIZABLE IsolationType = 0
	// SNAPSHOT TODO(jiajia) Needs documentation.
	SNAPSHOT IsolationType = 1
)

var IsolationType_name = map[int32]string{
	0: "SERIALIZABLE",
	1: "SNAPSHOT",
}

var IsolationType_value = map[string]int32{
	"SERIALIZABLE": 0,
	"SNAPSHOT":     1,
}

func (x IsolationType) Enum() *IsolationType {
	p := new(IsolationType)
	*p = x
	return p
}

func (x IsolationType) String() string {
	return proto.EnumName(IsolationType_name, int32(x))
}

func (x *IsolationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IsolationType_value, data, "IsolationType")
	if err != nil {
		return err
	}
	*x = IsolationType(value)
	return nil
}

func (IsolationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{0}
}

// TransactionStatus specifies possible states for a transaction.
type TransactionStatus int32

const (
	// PENDING is the default state for a new transaction. Transactions
	// move from PENDING to one of COMMITTED or ABORTED. Mutations made
	// as part of a PENDING transactions are recorded as "intents" in
	// the underlying MVCC model.
	PENDING TransactionStatus = 0
	// COMMITTED is the state for a transaction which has been
	// committed. Mutations made as part of a transaction which is moved
	// into COMMITTED state become durable and visible to other
	// transactions, moving from "intents" to permanent versioned
	// values.
	COMMITTED TransactionStatus = 1
	// ABORTED is the state for a transaction which has been aborted.
	// Mutations made as part of a transaction which is moved into
	// ABORTED state are deleted and are never made visible to other
	// transactions.
	ABORTED TransactionStatus = 2
)

var TransactionStatus_name = map[int32]string{
	0: "PENDING",
	1: "COMMITTED",
	2: "ABORTED",
}

var TransactionStatus_value = map[string]int32{
	"PENDING":   0,
	"COMMITTED": 1,
	"ABORTED":   2,
}

func (x TransactionStatus) Enum() *TransactionStatus {
	p := new(TransactionStatus)
	*p = x
	return p
}

func (x TransactionStatus) String() string {
	return proto.EnumName(TransactionStatus_name, int32(x))
}

func (x *TransactionStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TransactionStatus_value, data, "TransactionStatus")
	if err != nil {
		return err
	}
	*x = TransactionStatus(value)
	return nil
}

func (TransactionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{1}
}

// Timestamp represents a state of the hybrid logical clock.
type Timestamp struct {
	// Holds a wall time, typically a unix epoch time
	// Holds a wall time, typically a unix epoch time
	// expressed in nanoseconds.
	WallTime int64 `protobuf:"varint,1,opt,name=wall_time,json=wallTime" json:"wall_time"`
	// The logical component captures causality for events whose wall
	// times are equal. It is effectively bounded by (maximum clock
	// skew)/(minimal ns between events) and nearly impossible to
	// overflow.
	Logical              int32    `protobuf:"varint,2,opt,name=logical" json:"logical"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Timestamp) Reset()      { *m = Timestamp{} }
func (*Timestamp) ProtoMessage() {}
func (*Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{0}
}
func (m *Timestamp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Timestamp.Unmarshal(m, b)
}
func (m *Timestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Timestamp.Marshal(b, m, deterministic)
}
func (m *Timestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Timestamp.Merge(m, src)
}
func (m *Timestamp) XXX_Size() int {
	return xxx_messageInfo_Timestamp.Size(m)
}
func (m *Timestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_Timestamp.DiscardUnknown(m)
}

var xxx_messageInfo_Timestamp proto.InternalMessageInfo

func (m *Timestamp) GetWallTime() int64 {
	if m != nil {
		return m.WallTime
	}
	return 0
}

func (m *Timestamp) GetLogical() int32 {
	if m != nil {
		return m.Logical
	}
	return 0
}

// Value specifies the value at a key. Multiple values at the same key
// are supported based on timestamp. Values support the union of two
// basic types: a "bag o' bytes" generic byte slice and an incrementable
// int64, for use with the Increment API call.
type Value struct {
	// Bytes is the byte slice value. If this field is set, the integer field
	// should not be.
	Bytes []byte `protobuf:"bytes,1,opt,name=bytes" json:"bytes,omitempty"`
	// Integer is an integer value type. If this field is set, the bytes field
	// should not be. Only Integer values may exist at a key when making the
	// Increment API call.
	Integer *int64 `protobuf:"varint,2,opt,name=integer" json:"integer,omitempty"`
	// Checksum is a CRC-32-IEEE checksum of the key + value, in that order.
	// If this is an integer value, then the value is interpreted as an 8
	// byte, big-endian encoded value. This value is set by the client on
	// writes to do end-to-end integrity verification. If the checksum is
	// incorrect, the write operation will fail. If the client does not
	// wish to use end-to-end checksumming, this value should be nil.
	Checksum *uint32 `protobuf:"fixed32,3,opt,name=checksum" json:"checksum,omitempty"`
	// Timestamp of value.
	Timestamp *Timestamp `protobuf:"bytes,4,opt,name=timestamp" json:"timestamp,omitempty"`
	// Tag is an optional string value which can be used to add additional
	// metadata to this value. For example, Tag might provide information on how
	// the bytes in the "bytes" field should be interpreted.
	Tag                  *string  `protobuf:"bytes,5,opt,name=tag" json:"tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()    {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{1}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Value.Unmarshal(m, b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Value.Marshal(b, m, deterministic)
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return xxx_messageInfo_Value.Size(m)
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

func (m *Value) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

func (m *Value) GetInteger() int64 {
	if m != nil && m.Integer != nil {
		return *m.Integer
	}
	return 0
}

func (m *Value) GetChecksum() uint32 {
	if m != nil && m.Checksum != nil {
		return *m.Checksum
	}
	return 0
}

func (m *Value) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Value) GetTag() string {
	if m != nil && m.Tag != nil {
		return *m.Tag
	}
	return ""
}

// MVCCValue differentiates between normal versioned values and
// deletion tombstones.
type MVCCValue struct {
	// True to indicate a deletion tombstone. If false, value should not
	// be nil.
	Deleted bool `protobuf:"varint,1,opt,name=deleted" json:"deleted"`
	// The value. Nil if deleted is true; not nil otherwise.
	Value                *Value   `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MVCCValue) Reset()         { *m = MVCCValue{} }
func (m *MVCCValue) String() string { return proto.CompactTextString(m) }
func (*MVCCValue) ProtoMessage()    {}
func (*MVCCValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{2}
}
func (m *MVCCValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MVCCValue.Unmarshal(m, b)
}
func (m *MVCCValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MVCCValue.Marshal(b, m, deterministic)
}
func (m *MVCCValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCValue.Merge(m, src)
}
func (m *MVCCValue) XXX_Size() int {
	return xxx_messageInfo_MVCCValue.Size(m)
}
func (m *MVCCValue) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCValue.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCValue proto.InternalMessageInfo

func (m *MVCCValue) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *MVCCValue) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// KeyValue is a pair of Key and Value for returned Key/Value pairs
// from ScanRequest/ScanResponse. It embeds a Key and a Value.
type KeyValue struct {
	Key                  Key      `protobuf:"bytes,1,opt,name=key,customtype=Key" json:"key"`
	Value                Value    `protobuf:"bytes,2,opt,name=value" json:"value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{3}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyValue.Unmarshal(m, b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return xxx_messageInfo_KeyValue.Size(m)
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetValue() Value {
	if m != nil {
		return m.Value
	}
	return Value{}
}

// RawKeyValue contains the raw bytes of the value for a key.
type RawKeyValue struct {
	Key                  EncodedKey `protobuf:"bytes,1,opt,name=key,customtype=EncodedKey" json:"key"`
	Value                []byte     `protobuf:"bytes,2,opt,name=value" json:"value"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RawKeyValue) Reset()         { *m = RawKeyValue{} }
func (m *RawKeyValue) String() string { return proto.CompactTextString(m) }
func (*RawKeyValue) ProtoMessage()    {}
func (*RawKeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{4}
}
func (m *RawKeyValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RawKeyValue.Unmarshal(m, b)
}
func (m *RawKeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RawKeyValue.Marshal(b, m, deterministic)
}
func (m *RawKeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawKeyValue.Merge(m, src)
}
func (m *RawKeyValue) XXX_Size() int {
	return xxx_messageInfo_RawKeyValue.Size(m)
}
func (m *RawKeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_RawKeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_RawKeyValue proto.InternalMessageInfo

func (m *RawKeyValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// A StoreIdent uniquely identifies a store in the cluster. The
// StoreIdent is written to the underlying storage engine at a
// store-reserved system key (KeyLocalIdent).
type StoreIdent struct {
	ClusterID            string   `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId" json:"cluster_id"`
	NodeID               int32    `protobuf:"varint,2,opt,name=node_id,json=nodeId" json:"node_id"`
	StoreID              int32    `protobuf:"varint,3,opt,name=store_id,json=storeId" json:"store_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StoreIdent) Reset()         { *m = StoreIdent{} }
func (m *StoreIdent) String() string { return proto.CompactTextString(m) }
func (*StoreIdent) ProtoMessage()    {}
func (*StoreIdent) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{5}
}
func (m *StoreIdent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StoreIdent.Unmarshal(m, b)
}
func (m *StoreIdent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StoreIdent.Marshal(b, m, deterministic)
}
func (m *StoreIdent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreIdent.Merge(m, src)
}
func (m *StoreIdent) XXX_Size() int {
	return xxx_messageInfo_StoreIdent.Size(m)
}
func (m *StoreIdent) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreIdent.DiscardUnknown(m)
}

var xxx_messageInfo_StoreIdent proto.InternalMessageInfo

func (m *StoreIdent) GetClusterID() string {
	if m != nil {
		return m.ClusterID
	}
	return ""
}

func (m *StoreIdent) GetNodeID() int32 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *StoreIdent) GetStoreID() int32 {
	if m != nil {
		return m.StoreID
	}
	return 0
}

// A SplitTrigger is run after a successful commit of an AdminSplit
// command. It provides the updated range descriptor covering the
// first half of the split and the new range descriptor covering the
// second half. This information allows the final bookkeeping for
// the split to be completed and the new range put into operation.
type SplitTrigger struct {
	UpdatedDesc          RangeDescriptor `protobuf:"bytes,1,opt,name=updated_desc,json=updatedDesc" json:"updated_desc"`
	NewDesc              RangeDescriptor `protobuf:"bytes,2,opt,name=new_desc,json=newDesc" json:"new_desc"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SplitTrigger) Reset()         { *m = SplitTrigger{} }
func (m *SplitTrigger) String() string { return proto.CompactTextString(m) }
func (*SplitTrigger) ProtoMessage()    {}
func (*SplitTrigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{6}
}
func (m *SplitTrigger) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SplitTrigger.Unmarshal(m, b)
}
func (m *SplitTrigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SplitTrigger.Marshal(b, m, deterministic)
}
func (m *SplitTrigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitTrigger.Merge(m, src)
}
func (m *SplitTrigger) XXX_Size() int {
	return xxx_messageInfo_SplitTrigger.Size(m)
}
func (m *SplitTrigger) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitTrigger.DiscardUnknown(m)
}

var xxx_messageInfo_SplitTrigger proto.InternalMessageInfo

func (m *SplitTrigger) GetUpdatedDesc() RangeDescriptor {
	if m != nil {
		return m.UpdatedDesc
	}
	return RangeDescriptor{}
}

func (m *SplitTrigger) GetNewDesc() RangeDescriptor {
	if m != nil {
		return m.NewDesc
	}
	return RangeDescriptor{}
}

// NodeList keeps a growing set of NodeIDs as a sorted slice, with Add()
// adding to the set and Contains() verifying membership.
type NodeList struct {
	Nodes                []int32  `protobuf:"varint,1,rep,packed,name=nodes" json:"nodes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeList) Reset()         { *m = NodeList{} }
func (m *NodeList) String() string { return proto.CompactTextString(m) }
func (*NodeList) ProtoMessage()    {}
func (*NodeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{7}
}
func (m *NodeList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeList.Unmarshal(m, b)
}
func (m *NodeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeList.Marshal(b, m, deterministic)
}
func (m *NodeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeList.Merge(m, src)
}
func (m *NodeList) XXX_Size() int {
	return xxx_messageInfo_NodeList.Size(m)
}
func (m *NodeList) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeList.DiscardUnknown(m)
}

var xxx_messageInfo_NodeList proto.InternalMessageInfo

func (m *NodeList) GetNodes() []int32 {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// A Transaction is a unit of work performed on the database.
// Cockroach transactions support two isolation levels: snapshot
// isolation and serializable snapshot isolation. Each Cockroach
// transaction is assigned a random priority. This priority will be
// used to decide whether a transaction will be aborted during
// contention.
type Transaction struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// Key is the key which anchors the transaction. This is typically
	// the first key read or written during the transaction and
	// determines which range in the cluster will hold the transaction
	// record.
	Key Key `protobuf:"bytes,2,opt,name=key,customtype=Key" json:"key"`
	// ID is a unique UUID value which identifies the transaction.
	ID        []byte            `protobuf:"bytes,3,opt,name=id" json:"id"`
	Priority  int32             `protobuf:"varint,4,opt,name=priority" json:"priority"`
	Isolation IsolationType     `protobuf:"varint,5,opt,name=isolation,enum=proto.IsolationType" json:"isolation"`
	Status    TransactionStatus `protobuf:"varint,6,opt,name=status,enum=proto.TransactionStatus" json:"status"`
	// Incremented on txn retry.
	Epoch int32 `protobuf:"varint,7,opt,name=epoch" json:"epoch"`
	// The last heartbeat timestamp.
	LastHeartbeat *Timestamp `protobuf:"bytes,8,opt,name=last_heartbeat,json=lastHeartbeat" json:"last_heartbeat,omitempty"`
	// The proposed timestamp for the transaction. This starts as
	// the current wall time on the txn coordinator.
	Timestamp Timestamp `protobuf:"bytes,9,opt,name=timestamp" json:"timestamp"`
	// The original timestamp at which the transaction started. For serializable
	// transactions, if the timestamp drifts from the original timestamp, the
	// transaction will retry.
	OrigTimestamp Timestamp `protobuf:"bytes,10,opt,name=orig_timestamp,json=origTimestamp" json:"orig_timestamp"`
	// Initial Timestamp + clock skew. Reads which encounter values with
	// timestamps between Timestamp and MaxTimestamp trigger a txn
	// retry error, unless the node being read is listed in nodes_read
	// (in which case no more read uncertainty can occur).
	// The case MaxTimestamp < Timestamp is possible for transactions which have
	// been pushed; in this case, MaxTimestamp should be ignored.
	MaxTimestamp Timestamp `protobuf:"bytes,11,opt,name=max_timestamp,json=maxTimestamp" json:"max_timestamp"`
	// A sorted list of ids of nodes for which a ReadWithinUncertaintyIntervalError
	// occurred during a prior read. The purpose of keeping this information is
	// that as a reaction to this error, the transaction's timestamp is forwarded
	// appropriately to reflect that node's clock uncertainty. Future reads to
	// the same node are therefore freed from uncertainty restarts.
	//
	// The exact mechanism is that upon encountering the above error, the trans-
	// action will have to retry with a higher timestamp. This higher timestamp
	// is either the one of the encountered future write returned in the error
	// or (if higher, which is in the majority of cases), the time of the node
	// serving the key at the time of the failed read.
	// Additionally storing the node, we make sure to set MaxTimestamp=Timestamp
	// at the time of the read for nodes whose clock we've taken into acount,
	// which amounts to reading without any uncertainty.
	//
	// Bits of this mechanism are found in the local sender, the range and the
	// txn_coord_sender, with brief comments referring here.
	// See https://github.com/cockroachdb/cockroach/pull/221.
	CertainNodes         NodeList `protobuf:"bytes,12,opt,name=certain_nodes,json=certainNodes" json:"certain_nodes"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Transaction) Reset()      { *m = Transaction{} }
func (*Transaction) ProtoMessage() {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{8}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Transaction.Unmarshal(m, b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Transaction.Marshal(b, m, deterministic)
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return xxx_messageInfo_Transaction.Size(m)
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

func (m *Transaction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Transaction) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Transaction) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Transaction) GetIsolation() IsolationType {
	if m != nil {
		return m.Isolation
	}
	return SERIALIZABLE
}

func (m *Transaction) GetStatus() TransactionStatus {
	if m != nil {
		return m.Status
	}
	return PENDING
}

func (m *Transaction) GetEpoch() int32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Transaction) GetLastHeartbeat() *Timestamp {
	if m != nil {
		return m.LastHeartbeat
	}
	return nil
}

func (m *Transaction) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

func (m *Transaction) GetOrigTimestamp() Timestamp {
	if m != nil {
		return m.OrigTimestamp
	}
	return Timestamp{}
}

func (m *Transaction) GetMaxTimestamp() Timestamp {
	if m != nil {
		return m.MaxTimestamp
	}
	return Timestamp{}
}

func (m *Transaction) GetCertainNodes() NodeList {
	if m != nil {
		return m.CertainNodes
	}
	return NodeList{}
}

// MVCCMetadata holds MVCC metadata for a key. Used by storage/engine/mvcc.go.
type MVCCMetadata struct {
	Txn *Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn,omitempty"`
	// The timestamp of the most recent versioned value.
	Timestamp Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
	// Is the most recent value a deletion tombstone?
	Deleted bool `protobuf:"varint,3,opt,name=deleted" json:"deleted"`
	// The size in bytes of the most recent encoded key.
	KeyBytes int64 `protobuf:"varint,4,opt,name=key_bytes,json=keyBytes" json:"key_bytes"`
	// The size in bytes of the most recent versioned value.
	ValBytes int64 `protobuf:"varint,5,opt,name=val_bytes,json=valBytes" json:"val_bytes"`
	// Inline value, used for values with zero timestamp. This provides
	// an efficient short circuit of the normal MVCC metadata sentinel
	// and subsequent version rows. If timestamp == (0, 0), then there
	// is only a single MVCC metadata row with value inlined, and with
	// empty timestamp, key_bytes, and val_bytes.
	Value                *Value   `protobuf:"bytes,6,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MVCCMetadata) Reset()         { *m = MVCCMetadata{} }
func (m *MVCCMetadata) String() string { return proto.CompactTextString(m) }
func (*MVCCMetadata) ProtoMessage()    {}
func (*MVCCMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{9}
}
func (m *MVCCMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MVCCMetadata.Unmarshal(m, b)
}
func (m *MVCCMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MVCCMetadata.Marshal(b, m, deterministic)
}
func (m *MVCCMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCMetadata.Merge(m, src)
}
func (m *MVCCMetadata) XXX_Size() int {
	return xxx_messageInfo_MVCCMetadata.Size(m)
}
func (m *MVCCMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCMetadata proto.InternalMessageInfo

func (m *MVCCMetadata) GetTxn() *Transaction {
	if m != nil {
		return m.Txn
	}
	return nil
}

func (m *MVCCMetadata) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

func (m *MVCCMetadata) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *MVCCMetadata) GetKeyBytes() int64 {
	if m != nil {
		return m.KeyBytes
	}
	return 0
}

func (m *MVCCMetadata) GetValBytes() int64 {
	if m != nil {
		return m.ValBytes
	}
	return 0
}

func (m *MVCCMetadata) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// GCMetadata holds stats describing the state of data on disk after a
// garbage collection pass. These stats are used to prioritize system
// GC passes and enable the scheduler to avoid GCing ranges which have
// very little sufficiently aged data.
type GCMetadata struct {
	// The GC TTL for the range at last GC.
	TTLSeconds int32 `protobuf:"varint,1,opt,name=ttl_seconds,json=ttlSeconds" json:"ttl_seconds"`
	// Byte_counts is an array of byte counts with 10 entries. Each array
	// entry corresponds to the number of non-live (historical) bytes aged
	// less than some fraction of the TTL. The first entry in the array
	// is the number of bytes aged less than 10% of the TTL; the second,
	// the number aged less than 20%; etc...
	//
	// These are values at last GC, so given the current time,
	// last_gc_nanos, and ttl_seconds, the count of bytes to be GC'd can
	// be estimated.
	ByteCounts           []int64  `protobuf:"varint,2,rep,name=byte_counts,json=byteCounts" json:"byte_counts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GCMetadata) Reset()         { *m = GCMetadata{} }
func (m *GCMetadata) String() string { return proto.CompactTextString(m) }
func (*GCMetadata) ProtoMessage()    {}
func (*GCMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{10}
}
func (m *GCMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GCMetadata.Unmarshal(m, b)
}
func (m *GCMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GCMetadata.Marshal(b, m, deterministic)
}
func (m *GCMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCMetadata.Merge(m, src)
}
func (m *GCMetadata) XXX_Size() int {
	return xxx_messageInfo_GCMetadata.Size(m)
}
func (m *GCMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_GCMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_GCMetadata proto.InternalMessageInfo

func (m *GCMetadata) GetTTLSeconds() int32 {
	if m != nil {
		return m.TTLSeconds
	}
	return 0
}

func (m *GCMetadata) GetByteCounts() []int64 {
	if m != nil {
		return m.ByteCounts
	}
	return nil
}

// ScanMetadata holds information about last complete key/value scan
// of a range.
type ScanMetadata struct {
	// The last scan timestamp in nanoseconds since the Unix epoch.
	LastScanNanos int64 `protobuf:"varint,1,opt,name=last_scan_nanos,json=lastScanNanos" json:"last_scan_nanos"`
	// The oldest unresolved write intent in nanoseconds since epoch.
	// Null if there are no unresolved write intents.
	OldestIntentNanos *int64 `protobuf:"varint,2,opt,name=oldest_intent_nanos,json=oldestIntentNanos" json:"oldest_intent_nanos,omitempty"`
	// GC information from last scan.
	GC                   GCMetadata `protobuf:"bytes,3,opt,name=gc" json:"gc"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ScanMetadata) Reset()         { *m = ScanMetadata{} }
func (m *ScanMetadata) String() string { return proto.CompactTextString(m) }
func (*ScanMetadata) ProtoMessage()    {}
func (*ScanMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{11}
}
func (m *ScanMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ScanMetadata.Unmarshal(m, b)
}
func (m *ScanMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ScanMetadata.Marshal(b, m, deterministic)
}
func (m *ScanMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanMetadata.Merge(m, src)
}
func (m *ScanMetadata) XXX_Size() int {
	return xxx_messageInfo_ScanMetadata.Size(m)
}
func (m *ScanMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ScanMetadata proto.InternalMessageInfo

func (m *ScanMetadata) GetLastScanNanos() int64 {
	if m != nil {
		return m.LastScanNanos
	}
	return 0
}

func (m *ScanMetadata) GetOldestIntentNanos() int64 {
	if m != nil && m.OldestIntentNanos != nil {
		return *m.OldestIntentNanos
	}
	return 0
}

func (m *ScanMetadata) GetGC() GCMetadata {
	if m != nil {
		return m.GC
	}
	return GCMetadata{}
}

// TimeSeriesDatapoint is a single point of time series data; a value associated
// with a timestamp.
type TimeSeriesDatapoint struct {
	// The timestamp when this datapoint is located, expressed in nanoseconds
	// since the unix epoch.
	TimestampNanos int64 `protobuf:"varint,1,opt,name=timestamp_nanos,json=timestampNanos" json:"timestamp_nanos"`
	// An integer representation of the value of this datapoint. If this field
	// is set, then 'float_value' must not be set.
	IntValue *int64 `protobuf:"varint,2,opt,name=int_value,json=intValue" json:"int_value,omitempty"`
	// A floating point representation of the value of this datapoint. If this
	// field is set, then 'int_value' must not be set.
	FloatValue           *float32 `protobuf:"fixed32,3,opt,name=float_value,json=floatValue" json:"float_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TimeSeriesDatapoint) Reset()         { *m = TimeSeriesDatapoint{} }
func (m *TimeSeriesDatapoint) String() string { return proto.CompactTextString(m) }
func (*TimeSeriesDatapoint) ProtoMessage()    {}
func (*TimeSeriesDatapoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{12}
}
func (m *TimeSeriesDatapoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TimeSeriesDatapoint.Unmarshal(m, b)
}
func (m *TimeSeriesDatapoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TimeSeriesDatapoint.Marshal(b, m, deterministic)
}
func (m *TimeSeriesDatapoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeSeriesDatapoint.Merge(m, src)
}
func (m *TimeSeriesDatapoint) XXX_Size() int {
	return xxx_messageInfo_TimeSeriesDatapoint.Size(m)
}
func (m *TimeSeriesDatapoint) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeSeriesDatapoint.DiscardUnknown(m)
}

var xxx_messageInfo_TimeSeriesDatapoint proto.InternalMessageInfo

func (m *TimeSeriesDatapoint) GetTimestampNanos() int64 {
	if m != nil {
		return m.TimestampNanos
	}
	return 0
}

func (m *TimeSeriesDatapoint) GetIntValue() int64 {
	if m != nil && m.IntValue != nil {
		return *m.IntValue
	}
	return 0
}

func (m *TimeSeriesDatapoint) GetFloatValue() float32 {
	if m != nil && m.FloatValue != nil {
		return *m.FloatValue
	}
	return 0
}

// TimeSeriesData is a set of observations of a single variable value at
// multiple points in time. This message contains a string which uniquely
// identifies the source variable, and a repeated set of TimeSeriesDatapoint
// messages representing distinct measurements of that variable.
type TimeSeriesData struct {
	// A string which uniquely identifies the variable from which this data was
	// measured.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// Datapoints representing one or more measurements taken from the variable.
	Datapoints           []*TimeSeriesDatapoint `protobuf:"bytes,2,rep,name=datapoints" json:"datapoints,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TimeSeriesData) Reset()         { *m = TimeSeriesData{} }
func (m *TimeSeriesData) String() string { return proto.CompactTextString(m) }
func (*TimeSeriesData) ProtoMessage()    {}
func (*TimeSeriesData) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{13}
}
func (m *TimeSeriesData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TimeSeriesData.Unmarshal(m, b)
}
func (m *TimeSeriesData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TimeSeriesData.Marshal(b, m, deterministic)
}
func (m *TimeSeriesData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeSeriesData.Merge(m, src)
}
func (m *TimeSeriesData) XXX_Size() int {
	return xxx_messageInfo_TimeSeriesData.Size(m)
}
func (m *TimeSeriesData) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeSeriesData.DiscardUnknown(m)
}

var xxx_messageInfo_TimeSeriesData proto.InternalMessageInfo

func (m *TimeSeriesData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TimeSeriesData) GetDatapoints() []*TimeSeriesDatapoint {
	if m != nil {
		return m.Datapoints
	}
	return nil
}

func init() {
	proto.RegisterEnum("proto.IsolationType", IsolationType_name, IsolationType_value)
	proto.RegisterEnum("proto.TransactionStatus", TransactionStatus_name, TransactionStatus_value)
	proto.RegisterType((*Timestamp)(nil), "proto.Timestamp")
	proto.RegisterType((*Value)(nil), "proto.Value")
	proto.RegisterType((*MVCCValue)(nil), "proto.MVCCValue")
	proto.RegisterType((*KeyValue)(nil), "proto.KeyValue")
	proto.RegisterType((*RawKeyValue)(nil), "proto.RawKeyValue")
	proto.RegisterType((*StoreIdent)(nil), "proto.StoreIdent")
	proto.RegisterType((*SplitTrigger)(nil), "proto.SplitTrigger")
	proto.RegisterType((*NodeList)(nil), "proto.NodeList")
	proto.RegisterType((*Transaction)(nil), "proto.Transaction")
	proto.RegisterType((*MVCCMetadata)(nil), "proto.MVCCMetadata")
	proto.RegisterType((*GCMetadata)(nil), "proto.GCMetadata")
	proto.RegisterType((*ScanMetadata)(nil), "proto.ScanMetadata")
	proto.RegisterType((*TimeSeriesDatapoint)(nil), "proto.TimeSeriesDatapoint")
	proto.RegisterType((*TimeSeriesData)(nil), "proto.TimeSeriesData")
}

func init() { proto.RegisterFile("data.proto", fileDescriptor_871986018790d2fd) }

var fileDescriptor_871986018790d2fd = []byte{
	// 1124 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x36, 0x29, 0xc9, 0x12, 0x87, 0x94, 0x2c, 0x6f, 0x82, 0x17, 0x84, 0x5e, 0x34, 0x52, 0x84,
	0x14, 0x15, 0x82, 0xc6, 0x29, 0xd4, 0x8f, 0x14, 0x29, 0x8a, 0xc2, 0x92, 0x0c, 0x87, 0x88, 0x3f,
	0x02, 0x4a, 0xc8, 0xa1, 0x17, 0x62, 0x4d, 0xae, 0x69, 0xc2, 0xd4, 0xae, 0x40, 0xae, 0x6c, 0xeb,
	0xda, 0x53, 0xee, 0x45, 0x81, 0x02, 0xbd, 0x14, 0xe8, 0x0f, 0xe9, 0xb5, 0xbf, 0xa1, 0x07, 0x1f,
	0xf2, 0x1b, 0xfa, 0x03, 0x8a, 0xfd, 0xa0, 0x24, 0x37, 0xb6, 0x91, 0x93, 0xb8, 0x33, 0xcf, 0x33,
	0x3b, 0xb3, 0x3b, 0xf3, 0xac, 0x00, 0x22, 0xcc, 0xf1, 0xce, 0x2c, 0x63, 0x9c, 0xa1, 0x8a, 0xfc,
	0x69, 0x39, 0x21, 0xa3, 0xa7, 0x49, 0xac, 0x8c, 0xad, 0x67, 0x71, 0xc2, 0xcf, 0xe6, 0x27, 0x3b,
	0x21, 0x9b, 0x3e, 0x8f, 0x59, 0xcc, 0x9e, 0x4b, 0xf3, 0xc9, 0xfc, 0x54, 0xae, 0xe4, 0x42, 0x7e,
	0x29, 0x78, 0x77, 0x02, 0xd6, 0x24, 0x99, 0x92, 0x9c, 0xe3, 0xe9, 0x0c, 0x3d, 0x06, 0xeb, 0x12,
	0xa7, 0x69, 0xc0, 0x93, 0x29, 0x71, 0x8d, 0x8e, 0xd1, 0x2b, 0x0d, 0xca, 0x7f, 0x5d, 0xb7, 0x37,
	0xfc, 0x9a, 0x30, 0x0b, 0x1c, 0x7a, 0x04, 0xd5, 0x94, 0xc5, 0x49, 0x88, 0x53, 0xd7, 0xec, 0x18,
	0xbd, 0x8a, 0x06, 0x14, 0xc6, 0x97, 0xe5, 0x5f, 0x7f, 0x6f, 0x6f, 0x74, 0x7f, 0x31, 0xa0, 0xf2,
	0x16, 0xa7, 0x73, 0x82, 0x1e, 0x42, 0xe5, 0x64, 0xc1, 0x49, 0x2e, 0xc3, 0x39, 0xbe, 0x5a, 0x20,
	0x17, 0xaa, 0x09, 0xe5, 0x24, 0x26, 0x99, 0x8c, 0x52, 0xf2, 0x8b, 0x25, 0x6a, 0x41, 0x2d, 0x3c,
	0x23, 0xe1, 0x79, 0x3e, 0x9f, 0xba, 0xa5, 0x8e, 0xd1, 0xab, 0xfa, 0xcb, 0x35, 0xda, 0x01, 0x8b,
	0x17, 0xb9, 0xba, 0xe5, 0x8e, 0xd1, 0xb3, 0xfb, 0x4d, 0x55, 0xc6, 0xce, 0xb2, 0x06, 0x7f, 0x05,
	0x41, 0x4d, 0x28, 0x71, 0x1c, 0xbb, 0x95, 0x8e, 0xd1, 0xb3, 0x7c, 0xf1, 0xd9, 0x3d, 0x06, 0xeb,
	0xf0, 0xed, 0x70, 0xa8, 0x52, 0x7b, 0x04, 0xd5, 0x88, 0xa4, 0x84, 0x93, 0x48, 0x26, 0x57, 0x2b,
	0x4a, 0xd1, 0x46, 0xd4, 0x85, 0xca, 0x85, 0x00, 0xca, 0x14, 0xed, 0xbe, 0xa3, 0xb7, 0x92, 0x64,
	0x5f, 0xb9, 0xba, 0x63, 0xa8, 0xbd, 0x26, 0x0b, 0x15, 0xef, 0x13, 0x28, 0x9d, 0x93, 0x85, 0x2a,
	0x74, 0x60, 0x8b, 0x58, 0x7f, 0x5f, 0xb7, 0x4b, 0xaf, 0xc9, 0xc2, 0x17, 0x76, 0xd4, 0xbb, 0x27,
	0x9c, 0xde, 0x5a, 0x07, 0x3d, 0x06, 0xdb, 0xc7, 0x97, 0xcb, 0xb8, 0x4f, 0xd6, 0xe3, 0x22, 0x1d,
	0x17, 0xf6, 0x68, 0xc8, 0x22, 0x12, 0x2d, 0xc3, 0xb7, 0xd6, 0xc3, 0x3b, 0x37, 0x03, 0xfe, 0x6c,
	0x00, 0x8c, 0x39, 0xcb, 0x88, 0x17, 0x11, 0xca, 0xd1, 0x17, 0x00, 0x61, 0x3a, 0xcf, 0x39, 0xc9,
	0x82, 0x44, 0xd5, 0x6e, 0x0d, 0xb6, 0x05, 0xfe, 0xfd, 0x75, 0xdb, 0x1a, 0x2a, 0x8f, 0x37, 0xf2,
	0x2d, 0x0d, 0xf2, 0x22, 0xf4, 0x19, 0x54, 0x29, 0x8b, 0x88, 0x80, 0xab, 0x5b, 0x6f, 0x68, 0xf8,
	0xe6, 0x11, 0x8b, 0x88, 0x37, 0xf2, 0x37, 0x85, 0xdb, 0x8b, 0xd0, 0x53, 0xa8, 0xe5, 0x62, 0x23,
	0x81, 0x2c, 0x49, 0xe4, 0x96, 0x46, 0x56, 0x55, 0x02, 0x23, 0xbf, 0x9a, 0xab, 0x4c, 0xba, 0xef,
	0x0c, 0x70, 0xc6, 0xb3, 0x34, 0xe1, 0x93, 0x2c, 0x89, 0xc5, 0xdd, 0xff, 0x00, 0xce, 0x7c, 0x16,
	0x61, 0x4e, 0xa2, 0x20, 0x22, 0x79, 0x28, 0x33, 0xb3, 0xfb, 0xff, 0xd3, 0x07, 0xe5, 0x63, 0x1a,
	0x93, 0x11, 0xc9, 0xc3, 0x2c, 0x99, 0x71, 0x96, 0xe9, 0x0a, 0x6d, 0xcd, 0x10, 0x0e, 0xf4, 0x02,
	0x6a, 0x94, 0x5c, 0x2a, 0xb2, 0xf9, 0x11, 0xe4, 0x2a, 0x25, 0x97, 0xc2, 0xd8, 0x7d, 0x02, 0x35,
	0x51, 0xc8, 0x41, 0x92, 0x73, 0xe4, 0x42, 0x45, 0x14, 0x23, 0x3a, 0xb6, 0xd4, 0xab, 0x0c, 0xcc,
	0xa6, 0xe1, 0x2b, 0x43, 0xf7, 0xcf, 0x32, 0xd8, 0x93, 0x0c, 0xd3, 0x1c, 0x87, 0x3c, 0x61, 0x14,
	0xb9, 0x50, 0xa6, 0x58, 0x4f, 0x8a, 0xa5, 0x43, 0x4a, 0x4b, 0xd1, 0x0a, 0xe6, 0x1d, 0xad, 0xd0,
	0x02, 0x53, 0x9f, 0x8f, 0x33, 0x00, 0x7d, 0x3e, 0xa6, 0x37, 0xf2, 0xcd, 0x24, 0x42, 0x1d, 0xa8,
	0xcd, 0xb2, 0x84, 0x65, 0x09, 0x5f, 0xc8, 0x1e, 0x2f, 0x26, 0x6c, 0x69, 0x45, 0xdf, 0x82, 0x95,
	0xe4, 0x2c, 0xc5, 0x22, 0x07, 0xd9, 0xdc, 0x8d, 0xfe, 0x43, 0x5d, 0xa6, 0x57, 0xd8, 0x27, 0x8b,
	0x59, 0xd1, 0x54, 0x2b, 0x30, 0xfa, 0x06, 0x36, 0x73, 0x8e, 0xf9, 0x3c, 0x77, 0x37, 0x25, 0xcd,
	0x2d, 0xa6, 0x67, 0x55, 0xd4, 0x58, 0xfa, 0x35, 0x55, 0xa3, 0x45, 0x6f, 0x91, 0x19, 0x0b, 0xcf,
	0xdc, 0xea, 0x5a, 0x42, 0xca, 0x84, 0x5e, 0x40, 0x23, 0xc5, 0x39, 0x0f, 0xce, 0x08, 0xce, 0xf8,
	0x09, 0xc1, 0xdc, 0xad, 0xdd, 0x31, 0x99, 0x75, 0x81, 0x7b, 0x55, 0xc0, 0xd0, 0x57, 0xeb, 0xd3,
	0x6c, 0xdd, 0xce, 0x29, 0x4a, 0x58, 0xcd, 0xf4, 0xf7, 0xd0, 0x60, 0x59, 0x12, 0x07, 0x2b, 0x2a,
	0xdc, 0x4b, 0xad, 0x0b, 0xf4, 0x4a, 0xe1, 0xbe, 0x83, 0xfa, 0x14, 0x5f, 0xad, 0xb1, 0xed, 0x7b,
	0xd9, 0xce, 0x14, 0x5f, 0xad, 0xc8, 0x2f, 0xa1, 0x1e, 0x92, 0x8c, 0xe3, 0x84, 0x06, 0xaa, 0x43,
	0x1c, 0x49, 0xde, 0xd2, 0xe4, 0xa2, 0x83, 0x0a, 0xae, 0xc6, 0x0a, 0x73, 0xae, 0x75, 0xf1, 0x1f,
	0x03, 0x1c, 0x21, 0x40, 0x87, 0x84, 0x63, 0x21, 0xe4, 0x62, 0xb6, 0xf9, 0x15, 0xd5, 0x9d, 0x8e,
	0x3e, 0xbc, 0x0e, 0x5f, 0xb8, 0x6f, 0x1e, 0x95, 0xf9, 0xb1, 0x47, 0xb5, 0xa6, 0x6f, 0xa5, 0xdb,
	0xf4, 0xed, 0x31, 0x58, 0xe7, 0x64, 0x11, 0x28, 0x79, 0x2e, 0xaf, 0xab, 0xfd, 0x39, 0x59, 0x0c,
	0xa4, 0x4e, 0x3f, 0x06, 0xeb, 0x02, 0xa7, 0x1a, 0x52, 0x59, 0x87, 0x5c, 0xe0, 0x54, 0x41, 0x96,
	0x2a, 0xb9, 0x79, 0xb7, 0x4a, 0x9e, 0x01, 0xec, 0xaf, 0x6a, 0xfe, 0x12, 0x6c, 0xce, 0xd3, 0x20,
	0x27, 0x21, 0xa3, 0x91, 0x7a, 0x18, 0x2a, 0x4a, 0xd7, 0xde, 0x5f, 0xb7, 0x61, 0x32, 0x39, 0x18,
	0x2b, 0x8f, 0x0f, 0x9c, 0xa7, 0xfa, 0x1b, 0x7d, 0x0a, 0xb6, 0xc8, 0x22, 0x08, 0xd9, 0x9c, 0xf2,
	0xdc, 0x35, 0x3b, 0xa5, 0x65, 0x2e, 0x20, 0x1c, 0x43, 0x69, 0xef, 0xfe, 0x26, 0x34, 0x25, 0xc4,
	0x74, 0xb9, 0xd9, 0xe7, 0xb0, 0x25, 0xdb, 0x33, 0x0f, 0x31, 0x0d, 0x28, 0xa6, 0x2c, 0xbf, 0xf1,
	0xb0, 0xc9, 0x9e, 0x14, 0x84, 0x23, 0xe1, 0x42, 0x3b, 0xf0, 0x80, 0xa5, 0x11, 0xc9, 0x79, 0x20,
	0xde, 0x23, 0xca, 0x35, 0x43, 0xbd, 0x51, 0xdb, 0xca, 0xe5, 0x49, 0x8f, 0xc2, 0x3f, 0x03, 0x33,
	0x0e, 0xe5, 0xe9, 0xda, 0xfd, 0x6d, 0x5d, 0xf9, 0xaa, 0xd2, 0xd5, 0x6c, 0xef, 0x0f, 0x7d, 0x33,
	0x0e, 0xbb, 0x3f, 0x19, 0xf0, 0x40, 0x5c, 0xd8, 0x98, 0x64, 0x09, 0xc9, 0x47, 0x98, 0xe3, 0x19,
	0x4b, 0x28, 0x47, 0xcf, 0x60, 0x6b, 0x79, 0x6d, 0xb7, 0x24, 0xd9, 0x58, 0x3a, 0xd5, 0xae, 0xff,
	0x07, 0x2b, 0xa1, 0x3c, 0x58, 0xc9, 0x7d, 0xc9, 0xaf, 0x25, 0x94, 0xab, 0xd7, 0xa2, 0x0d, 0xf6,
	0x69, 0xca, 0x70, 0xe1, 0x16, 0xb9, 0x99, 0x3e, 0x48, 0x93, 0x04, 0x74, 0x4f, 0xa1, 0x71, 0x33,
	0x87, 0x7b, 0x74, 0xec, 0xa5, 0xfa, 0xbf, 0x21, 0xb3, 0x54, 0x87, 0x6e, 0xf7, 0x5b, 0x6b, 0x9d,
	0xf7, 0x9f, 0x42, 0xfc, 0x35, 0xf4, 0xd3, 0xaf, 0xa1, 0x7e, 0x43, 0x8e, 0x50, 0x13, 0x9c, 0xf1,
	0x9e, 0xef, 0xed, 0x1e, 0x78, 0x3f, 0xee, 0x0e, 0x0e, 0xf6, 0x9a, 0x1b, 0xc8, 0x81, 0xda, 0xf8,
	0x68, 0xf7, 0xcd, 0xf8, 0xd5, 0xf1, 0xa4, 0x69, 0xb4, 0xca, 0xef, 0xfe, 0x78, 0xb4, 0xf1, 0x74,
	0x00, 0xdb, 0x1f, 0xc8, 0x11, 0xb2, 0xa1, 0xfa, 0x66, 0xef, 0x68, 0xe4, 0x1d, 0xed, 0x37, 0x37,
	0x50, 0x1d, 0xac, 0xe1, 0xf1, 0xe1, 0xa1, 0x37, 0x99, 0xec, 0x8d, 0x9a, 0x86, 0xf0, 0xed, 0x0e,
	0x8e, 0x7d, 0xb1, 0x30, 0x55, 0x8c, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x3e, 0x4a, 0x42, 0x85,
	0x25, 0x09, 0x00, 0x00,
}
